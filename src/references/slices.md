---
minutes: 10
translated_at: '2024-03-26T10:19:25.683Z'
---

# 切片

切片为您提供了对更大集合的视图：

<!-- mdbook-xgettext: skip -->

```rust,editable
fn main() {
    let mut a: [i32; 6] = [10, 20, 30, 40, 50, 60];
    println!("a: {a:?}");

    let s: &[i32] = &a[2..4];

    println!("s: {s:?}");
}
```

- 切片从被切类型那里借用数据。
- 问题：如果在打印 `s` 之前修改了 `a[3]`，会发生什么情况？

<details>

- 我们通过借用 `a` 并在方括号中指定起始和结束索引来创建一个切片。

- 如果切片从索引 0 开始，Rust 的范围语法允许我们省略起始索引，这意味着 `&a[0..a.len()]` 和 `&a[..a.len()]` 是相同的。

- 对于最后一个索引也是如此，所以 `&a[2..a.len()]` 和 `&a[2..]` 是相同的。

- 若要轻松创建整个数组的切片，我们可以使用 `&a[..]`。

- `s` 是对 `i32` 切片的引用。请注意 `s` 的类型（`&[i32]`）不再提及数组长度。这使我们能够对不同大小的切片执行计算。

- 切片总是从另一个对象借用。在这个例子中，`a` 必须至少保持 “活着”（在作用域内），直到我们的切片不再使用。

- 关于修改 `a[3]` 的问题可以引发有趣的讨论，但答案是出于内存安全的原因，此时通过 `a` 你不能进行修改，但你可以安全地从 `a` 和 `s` 读取数据。在你创建切片之前它是可行的，以及在 `println` 之后，当切片不再被使用时，它再次变得可行。

</details>
