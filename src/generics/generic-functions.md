---
minutes: 5
translated_at: '2024-03-26T10:47:12.946Z'
---

# 泛型函数

Rust 支持泛型，这让你可以抽象算法或数据结构（如排序或二叉树）以适用于使用或存储的类型。

```rust,editable
/// 根据 `n` 的值选择 `even` 或 `odd`。
fn pick<T>(n: i32, even: T, odd: T) -> T {
    if n % 2 == 0 {
        even
    } else {
        odd
    }
}

fn main() {
    println!("选中了一个数字：{:?}", pick(97, 222, 333));
    println!("选中了一个元组：{:?}", pick(28, ("dog", 1), ("cat", 2)));
}
```

<details>

- Rust 会根据参数和返回值的类型来推断 T 的类型。

- 这与 C++ 的模板类似，但 Rust 会立即部分编译泛型函数，因此该函数必须对匹配约束的所有类型都有效。例如，尝试修改 `pick` 以在 `n == 0` 时返回 `even + odd`。即使只使用了整数情况下的 `pick` 实例化，Rust 仍会认为它是无效的。C++ 则允许你这么做。

- 泛型代码会基于调用位置转变为非泛型代码。这是一种零成本抽象：你获得的结果和你手动编码数据结构而不使用抽象完全一样。

</details>
