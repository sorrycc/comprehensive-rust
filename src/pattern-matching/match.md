---
minutes: 10
translated_at: '2024-03-26T10:22:03.570Z'
---

# 匹配值

`match` 关键字允许你将一个值与一个或多个 _模式_ 相匹配。比较会从上到下进行，且首个匹配成功的会胜出。

模式可以是简单值，类似 C 和 C++ 中的 `switch`：

```rust,editable
#[rustfmt::skip]
fn main() {
    let input = 'x';
    match input {
        'q'                       => println!("退出"),
        'a' | 's' | 'w' | 'd'     => println!("移动"),
        '0'..='9'                 => println!("数字输入"),
        key if key.is_lowercase() => println!("小写字母: {key}"),
        _                         => println!("其他内容"),
    }
}
```

`_` 模式是一个通配符模式，它可以匹配任何值。表达式 _必须_ 要穷尽所有可能，这意味着它要覆盖所有情况，所以 `_` 经常被用作最后的捕获所有情况的情况。

Match 可以被用作表达式。就像 `if`，每个 match 分支必须有相同的类型。类型是块的最后一个表达式，如果有的话。在上面的例子中，类型是 `()`。

模式中的变量（这个例子中的 `key`）将创建一个可以在 match 分支内使用的绑定。

匹配卫士使得分支只有在条件为真时才匹配。

<details>

关键点：

- 你可能要指出在模式中一些特定字符的使用
  - `|` 作为一个 `或`
  - `..` 可以扩展到它需要的程度
  - `1..=5` 表示一个包含性范围
  - `_` 是一个通配符

- 匹配卫士作为一个单独的语法特性很重要，当我们希望简洁地表达比单凭模式允许的更复杂的思想时，它是必要的。
- 它们与 match 分支内的单独 `if` 表达式不同。分支块内部（在 `=>` 之后的）的 `if` 表达式是在选择 match 分支之后发生的。在该块内部未通过 `if` 条件不会导致考虑原始 `match` 表达式的其他分支。
- 卫士中定义的条件适用于模式中的每一个表达式


与 `|` 一起使用。

</details>
