---
translated_at: '2024-03-26T11:42:17.406Z'
---

# 开始准备 Rust

在开始运行 Rust 代码之前，我们需要做一些初始化。

```armasm
{{#include examples/entry.S:entry}}
```

<details>

- 这和 C 语言的做法是相同的：初始化处理器状态、清零 BSS 段，并设置栈指针。
  - BSS（块起始符号，出于历史原因）是对象文件的一部分，包含了初始化为零的静态分配变量。它们从映像中省略掉，以避免浪费空间在零上。编译器假设加载器会负责将它们清零。
- BSS 可能已经被清零了，这取决于内存是如何初始化的，以及映像是如何加载的，但我们还是要清零以确认无误。
- 我们需要在读写任何内存之前启用 MMU 和缓存。如果我们不这样做：
  - 未对齐的访问将导致错误。我们为 `aarch64-unknown-none` 目标构建 Rust 代码，它设置了 `+strict-align` 以防止编译器生成未对齐的访问，所以这种情况下应该是没问题的，但这不一定总是适用。
  - 如果它在虚拟机中运行，这可能导致缓存一致性问题。问题是虚拟机在缓存禁用的情况下直接访问内存，而宿主机拥有对同一内存的可缓存别名。即使宿主机没有显式访问内存，预测性访问也可能导致缓存填充，然后缓存清理时或者虚拟机启用缓存时，来自它们之一的更改可能会丢失。（缓存是由物理地址索引，而不是虚拟地址或 IPA。）
- 为了简单起见，我们直接使用一个硬编码的页表（参见 `idmap.S`），它为设备映射地址空间的第一个 1 GiB、接下来的 1 GiB 用于 DRAM，以及更高的另一个 1 GiB 用于更多设备。这匹配了 QEMU 使用的内存布局。
- 我们还设置了异常向量（`vbar_el1`），稍后我们将详细了解。
- 今天下午的所有示例都假设我们会在异常级别 1 下运行。

```markdown
  (EL1)。如果你需要在不同的异常级别上运行，你将需要相应地修改 `entry.S`。
```
