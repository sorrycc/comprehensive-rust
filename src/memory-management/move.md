---
minutes: 5
translated_at: '2024-03-26T10:35:00.582Z'
---

# 移动语义

赋值会在变量间转移 _所有权_：

```rust,editable
fn main() {
    let s1: String = String::from("Hello!");
    let s2: String = s1;
    println!("s2: {s2}");
    // println!("s1: {s1}");
}
```

- `s1` 赋值给 `s2` 时发生了所有权的转移。
- 当 `s1` 离开作用域时，没有任何发生：它不拥有任何东西。
- 当 `s2` 离开作用域时，字符串数据被释放。

移动到 `s2` 之前：

```bob
 栈                                堆
.- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - -.
:                           :     :                                     :
:    s1                     :     :                                     :
:   +-----------+-------+   :     :   +----+----+----+----+----+----+   :
:   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  | !  |   :
:   | len       |     4 |   :     :   +----+----+----+----+----+----+   :
:   | capacity  |     4 |   :     :                                     :
:   +-----------+-------+   :     :                                     :
:                           :     `- - - - - - - - - - - - - - - - - - -'
:                           :
`- - - - - - - - - - - - - -'
```

移动到 `s2` 之后：

```bob
 栈                                堆
.- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - -.
:                           :     :                                     :
:    s1 "(无法访问)"        :     :                                     :
:   +-----------+-------+   :     :   +----+----+----+----+----+----+   :
:   | ptr       |   o---+---+--+--+-->| H  | e  | l  | l  | o  | !  |   :
:   | len       |     4 |   :  |  :   +----+----+----+----+----+----+   :
:   | capacity  |     4 |   :  |  :                                     :
:   +-----------+-------+   :  |  :                                     :
:                           :  |  `- - - - - - - - - - - - - - - - - - -'
:    s2                     :  |
:   +-----------+-------+   :  |
:   | ptr       |   o---+---+--'
:   | len       |     4 |   :
:   | capacity  |     4 |   :
:   +-----------+-------+   :
:                           :
`- - - - - - - - - - - - - -'
```

当你将一个值传递给函数时，该值会被赋给函数参数。这就转移了所有权：

```rust,editable
fn say_hello(name: String) {
    println!("Hello {name}")
}

fn main() {
    let name = String::from("Alice");
    say_hello(name);
    // say_hello(name);
}
```

<details>

- 提到这与 C++ 中的默认行为相反，C++ 默认是按值复制，除非你使用 `std::move`（并且定义了移动构造函数！）。

- 只有所有权在移动。是否生成机器码来操作数据本身是优化的问题，这样的复制会被积极优化掉。

- 简单值（如整数）可以被标记为 `Copy`（见后面的幻灯片）。

- 在 Rust 中，克隆是显式的（通过使用 `clone`）。

在 `say_hello` 示例中：

- 第一次调用 `say_hello` 时，`main` 放弃了 `name` 的所有权。此后，`name` 在 `main` 内不能再被使用。
- 为 `name` 分配的堆内存将在 `say_hello` 函数结束时被释放。
- 如果 `main` 通过引用（`&name`）传递 `name`，并且 `say_hello` 接受引用作为参数，那么 `main` 可以保留所有权。
- 或者，`main` 可以在第一次调用时传递 `name` 的克隆（`name.clone()`）。
- Rust 通过将移动语义设为默认行为，以及强迫程序员显式地制作克隆，使得不小心创建副本变得比 C++ 更困难。

# 更多探索

## 现代 C++ 中的防御性复制

现代 C++ 有不同的解决方式：

```c++
std::string s1 = "Cpp";
std::string s2 = s1;  // 复制 s1 中的数据。
```

- `s1` 的堆数据被复制，`s2` 获得它自己独立的副本。
- 当 `s1` 和 `s2` 离开作用域时，它们各自释放自己的内存。

在复制赋值之前：

```bob
 栈                                 堆
.- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.
:                           :     :                       :
:    s1                     :     :                       :
:   +-----------+-------+   :     :   +----+----+----+    :
:   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :
:   | len       |     3 |   :     :   +----+----+----+    :
:   | capacity  |     3 |   :     :                       :
:   +-----------+-------+   :     :                       :
:                           :     `- - - - - - - - - - - -'
`- - - - - - - - - - - - - -'
```

复制赋值后：

```bob
 栈                                 堆
.- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.
:                           :     :                       :
:    s1                     :     :                       :
:   +-----------+-------+   :     :   +----+----+----+    :
:   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :
:   | len       |     3 |   :     :   +----+----+----+    :
:   | capacity  |     3 |   :     :                       :
:   +-----------+-------+   :     :                       :
:                           :     :                       :
:    s2                     :     :                       :
:   +-----------+-------+   :     :   +----+----+----+    :
:   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :
:   | len       |     3 |   :     :   +----+----+----+    :
:   | capacity  |     3 |   :     :                       :
:   +-----------+-------+   :     :                       :
:                           :     `- - - - - - - - - - - -'
`- - - - - - - - - - - - - -'
```

要点：

- C++ 做出了与 Rust 略有不同的选择。因为 `=` 会复制数据，字符串数据必须被克隆。否则当任一字符串超出作用域时，我们会遇到双重释放的问题。

- C++ 还有 [`std::move`]，它用来表示一个值可能会被移动。如果示例是 `s2 = std::move(s1)`，那么不会发生堆分配。移动后，`s1` 将处于一个有效但未指定的状态。与 Rust 不同，程序员被允许继续使用 `s1`。

- 与 Rust 不同，C++ 中的 `=` 可以运行由被复制或移动的类型所确定的任意代码。

[`std::move`]: https://en.cppreference.com/w/cpp/utility/move

</details>
