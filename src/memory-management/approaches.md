---
minutes: 10
translated_at: '2024-03-26T10:37:39.675Z'
---

# 内存管理的方法

传统上，编程语言分为两大类：

- 通过手动内存管理获得完全控制：C、C++、Pascal, ...
  - 程序员决定何时分配或释放堆内存。
  - 程序员必须确定指针是否仍然指向有效内存。
  - 研究表明，程序员会犯错误。
- 通过运行时自动内存管理获得完全安全：Java、Python、Go、Haskell, ...
  - 运行时系统确保内存不会被释放，直到它不再被引用为止。
  - 通常使用引用计数、垃圾收集或 RAII 来实现。

Rust 提供了一种新的混合方式：

> 通过编译时强制执行正确的内存管理实现完全控制 _和_ 安全。

它通过一个明确的所有权概念来实现这一点。

<details>

此幻灯片旨在帮助来自其他语言的学生将 Rust 放在上下文中。

- C 必须手动使用 `malloc` 和 `free` 来管理堆。常见的错误包括忘记调用 `free`，对同一个指针调用它多次，或者在其指向的内存被释放后解引用一个指针。

- C++ 有像智能指针（`unique_ptr`, `shared_ptr`）这样的工具，它利用语言关于调用析构函数的保证来确保函数返回时内存被释放。尽管如此，仍然很容易误用这些工具，并创建与 C 相似的错误。

- Java、Go 和 Python 依赖垃圾收集器来识别不再可达的内存并丢弃它。这保证了任何指针都可以被解引用，消除了使用后自由和其他类别的错误。但是，GC 有运行时成本，并且很难适当地调整。

Rust 的所有权和借用模型在许多情况下，可以获得 C 的性能，精确地在需要的地方进行 alloc 和 free 操作 —— 零成本。它还提供了类似于 C++ 的智能指针的工具。在需要的时候，其他选项如引用计数也可用，并且甚至有支持运行时垃圾收集的第三方 crates（未涵盖）。

在这个课程中）。

</details>
